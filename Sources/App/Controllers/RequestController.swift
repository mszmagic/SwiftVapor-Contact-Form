//
//  File.swift
//  
//
//  Created by Shunzhe Ma on R 2/11/30.
//

import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

struct GithubEmailItem: Decodable {
    let email: String
    let primary: Bool
    let verified: Bool
    let visibility: String?
}

struct hcaptchaValidateResult: Decodable {
    let success: Bool
    let challenge_ts: String
    let hostname: String
}

struct LogInResult {
    var succeeded: Bool
    var code: String?
    var error: String?
    
    static func onSuccess(code: String) -> LogInResult {
        return .init(succeeded: true,
                     code: code,
                     error: nil)
    }
    
    static func onError(errorMessage: String?) -> LogInResult {
        return .init(succeeded: false,
                     code: nil,
                     error: errorMessage ?? "不明なエラー")
    }
    
}

/*
 Some part of the code here is generated by the Paw tool, which is a great tool for API debugging.
 */

class RequestController {
    
    static let shared = RequestController()
    
    func fetchToken(loginCode: String, completionHandler: @escaping (LogInResult) -> Void) {
        let sessionConfig = URLSessionConfiguration.default
        let session = URLSession(configuration: sessionConfig, delegate: nil, delegateQueue: nil)
        guard var URL = URL(string: "https://github.com/login/oauth/access_token") else {return}
        let URLParams = [
            "client_id": APICredentials.github_client_id,
            "client_secret": APICredentials.github_client_secret,
            "code": loginCode,
        ]
        URL = URL.appendingQueryParameters(URLParams)
        var request = URLRequest(url: URL)
        request.httpMethod = "POST"
        let task = session.dataTask(with: request, completionHandler: { (data: Data?, response: URLResponse?, error: Error?) -> Void in
            if (error == nil) {
                guard let responseData = data,
                      let responseString = String(data: responseData, encoding: .utf8) else {
                    completionHandler(.onError(errorMessage: "応答データのデコードに失敗しました。"))
                    return
                }
                // Succeeded, parse the result from Github
                let components = responseString.split(separator: "&")
                var responseParameters = [String: String]()
                for component in components {
                    let parameterComponents = component.split(separator: "=")
                    if parameterComponents.count == 2 {
                        responseParameters[String(parameterComponents[0])] = String(parameterComponents[1])
                    }
                }
                // Check for token
                if let accessToken = responseParameters["access_token"] {
                    completionHandler(.onSuccess(code: accessToken))
                } else {
                    let errorMessage = responseParameters["error"]
                    completionHandler(.onError(errorMessage: errorMessage))
                }
            }
            else {
                completionHandler(.onError(errorMessage: error?.localizedDescription))
            }
        })
        task.resume()
        session.finishTasksAndInvalidate()
    }
    
    func fetchEmailAddress(authToken: String, completionHandler: @escaping ([String]) -> Void) {
        let sessionConfig = URLSessionConfiguration.default
        let session = URLSession(configuration: sessionConfig, delegate: nil, delegateQueue: nil)
        
        guard let URL = URL(string: "https://api.github.com/user/emails") else {return}
        var request = URLRequest(url: URL)
        request.httpMethod = "GET"
        
        // Headers
        
        request.addValue("Bearer \(authToken)", forHTTPHeaderField: "Authorization")
        
        let task = session.dataTask(with: request, completionHandler: { (data: Data?, response: URLResponse?, error: Error?) -> Void in
            if (error == nil),
               let responseData = data {
                // Success
                // Try to parse the return JSON array of email addresses
                var emailAddresses = [String]()
                guard let emailObjects = try? JSONDecoder().decode(Array<GithubEmailItem>.self, from: responseData) else {
                    completionHandler([])
                    print("JSON解析エラー \(error?.localizedDescription ?? "").")
                    return
                }
                for object in emailObjects {
                    let email = object.email
                    if object.verified {
                        emailAddresses.append(email)
                    }
                }
                completionHandler(emailAddresses)
            }
            else {
                // Failure
                print("URL Session Task Failed: %@", error!.localizedDescription);
                completionHandler([])
            }
        })
        task.resume()
        session.finishTasksAndInvalidate()
    }
    
    func sendEmail(fromEmail: String, fromName: String, toEmail: String, title: String, content: String, completionHandler: @escaping (Int) -> Void) {
        let sessionConfig = URLSessionConfiguration.default
        
        let session = URLSession(configuration: sessionConfig, delegate: nil, delegateQueue: nil)
        guard let URL = URL(string: "https://api.eu.mailgun.net/v3/notifications.mszme.com/messages") else {return}
        var request = URLRequest(url: URL)
        request.httpMethod = "POST"
        
        // Headers
        let apiKey = "api:\(APICredentials.mailgun_sending_key)"
        let apiKeyEncoded = apiKey.data(using: .utf8)
        guard let encodedStr = apiKeyEncoded?.base64EncodedString() else {
            return
        }
        request.addValue("Basic \(encodedStr)", forHTTPHeaderField: "Authorization")
        request.addValue("application/x-www-form-urlencoded; charset=utf-8", forHTTPHeaderField: "Content-Type")
        
        // Form URL-Encoded Body
        
        let bodyParameters = [
            "from": "\(fromName) <\(fromEmail)>",
            "to": toEmail,
            "subject": title,
            "text": content,
        ]
        let bodyString = bodyParameters.queryParameters
        request.httpBody = bodyString.data(using: .utf8, allowLossyConversion: true)
        
        /* Start a new Task */
        let task = session.dataTask(with: request, completionHandler: { (data: Data?, response: URLResponse?, error: Error?) -> Void in
            if (error == nil) {
                // Success
                let statusCode = (response as! HTTPURLResponse).statusCode
                print("URL Session Task Succeeded: HTTP \(statusCode)")
                completionHandler(statusCode)
            }
            else {
                // Failure
                print("URL Session Task Failed: %@", error!.localizedDescription);
                completionHandler(500)
            }
        })
        task.resume()
        session.finishTasksAndInvalidate()
    }
    
    func checkCaptcha(clientCaptchaResponse: String, completionHandler: @escaping (Bool) -> Void) {
        let sessionConfig = URLSessionConfiguration.default
        let session = URLSession(configuration: sessionConfig, delegate: nil, delegateQueue: nil)
        
        guard let URL = URL(string: "https://hcaptcha.com/siteverify") else {return}
        var request = URLRequest(url: URL)
        request.httpMethod = "POST"
        
        // Headers
        
        request.addValue("application/x-www-form-urlencoded; charset=utf-8", forHTTPHeaderField: "Content-Type")
        
        // Form URL-Encoded Body
        
        let bodyParameters = [
            "response": clientCaptchaResponse,
            "secret": APICredentials.hcaptcha_secret_key,
        ]
        let bodyString = bodyParameters.queryParameters
        request.httpBody = bodyString.data(using: .utf8, allowLossyConversion: true)
        
        let task = session.dataTask(with: request, completionHandler: { (data: Data?, response: URLResponse?, error: Error?) -> Void in
            if (error == nil) {
                // Success
                if let fetchedData = data,
                   let result = try? JSONDecoder().decode(hcaptchaValidateResult.self, from: fetchedData) {
                    print("Captcha response object \(result)")
                    completionHandler(result.success)
                } else {
                    completionHandler(false)
                }
            }
            else {
                // Failure
                print("URL Session Task Failed: %@", error!.localizedDescription);
                completionHandler(false)
            }
        })
        task.resume()
        session.finishTasksAndInvalidate()
    }

}


protocol URLQueryParameterStringConvertible {
    var queryParameters: String {get}
}

extension Dictionary : URLQueryParameterStringConvertible {
    /**
     This computed property returns a query parameters string from the given NSDictionary. For
     example, if the input is @{@"day":@"Tuesday", @"month":@"January"}, the output
     string will be @"day=Tuesday&month=January".
     @return The computed parameters string.
     */
    var queryParameters: String {
        var parts: [String] = []
        for (key, value) in self {
            let part = String(describing: key).addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)! + "=" + String(describing: value).addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)!
            parts.append(part as String)
        }
        return parts.joined(separator: "&")
    }
    
}

extension URL {
    /**
     Creates a new URL by adding the given query parameters.
     @param parametersDictionary The query parameter dictionary to add.
     @return A new URL.
     */
    func appendingQueryParameters(_ parametersDictionary : Dictionary<String, String>) -> URL {
        let URLString : String = self.absoluteString + "?" + parametersDictionary.queryParameters
        return URL(string: URLString)!
    }
}


